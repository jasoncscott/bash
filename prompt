# =============================================================================
# PROMPT
# =============================================================================

# =============================================================================
# HOSTNAME
# =============================================================================

.host() {
    USER_HOST_LOC=USER_HOST_${M_LOCATION^^}
    case ${HOSTNAME} in
        ${!USER_HOST_LOC})
            printf "MAIN ${M_LOCATION^^} HOST - ${HOSTNAME}"
            ;;
        ${USER_HOST_GUAC}*)
            printf 'GUACAMOLE'
            ;;
        [[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]]*)
            printf 'DOCKER'
            ;;
        *)
            printf ${HOSTNAME}
            ;;
    esac
}


# =============================================================================
# SHLVL
# =============================================================================

if [ -z ${SHLVL_INIT} ] && [[ $- == *i* ]]; then
    export SHLVL_INIT=${SHLVL}
fi

.subshell() {
    if [ ${SHLVL} -gt ${SHLVL_INIT} ]; then
        printf " \e[7;3;4m(Subshell)"
    fi

    if ! [ -z ${REZ_VERSION} ]; then
        printf " \e[7;3;4m(REZ)"
    fi
}

# =============================================================================
# LOCAL / REMOTE / DOCKER
# =============================================================================

.remote() {
    ssh_process=$(ps -no-headers -o comm ${PPID} | grep "sshd")

    if [ "${ssh_process}" != "sshd" ]; then
        if [ "$(grep docker /proc/1/cgroup)" ]; then
            printf "\e[7;3;4mDocker"
            echo -ne "\033]0;Docker\007"
        else
            printf "Local"
        fi
    else
        printf "\e[7mRemote"
    fi
}


# =============================================================================
# PIPELINE
# =============================================================================

# Set default values for variables that don't exist yet
.m_variables() {
    if [ -z "${M_JOB}" ]; then printf "[none]"; else printf "${M_JOB}"; fi
    if [ -z "${M_SEQUENCE}" ]; then printf "/[none]"; else printf "/${M_SEQUENCE}"; fi
    if [ -z "${M_SHOT}" ]; then printf "/[none]"; else printf "/${M_SHOT}"; fi
    if [ -z "${M_TASK}" ]; then printf ":[none]"; else printf ":${M_TASK}"; fi
}


# =============================================================================
# TITLE
# =============================================================================

.title() {
    title=$(xprop -id $(xprop -root 32x '\t$0' _NET_ACTIVE_WINDOW | cut -f 2) _NET_WM_NAME | awk -F\" '{print $2}')
    #echo -ne "\033]0;${title}\007";

    # Change Konsole Tab Title
    #if [ -n "${KONSOLE_DBUS_SESSION}" ]; then
    #    qdbus org.kde.konsole ${KONSOLE_DBUS_SESSION} org.kde.konsole.Session.setTitle 1 ${M_LEVEL}:${M_TASK};
    #fi
}


# =============================================================================
# __git_ps1 PRE
# =============================================================================

# Single quotes to preserve functions for __git_ps1; double quotes for colors
# Separate each command with a blank newline
__git_ps1_pre="\n\n"

__git_ps1_pre+="\[${BIRed}\]"
# Location
#__git_ps1_pre+='$(printf '%4s' ${M_LOCATION^^})'
__git_ps1_pre+="\[${Color_Off}\]"

__git_ps1_pre+=' | '

__git_ps1_pre+="\[${BIGreen}\]"
# Prompt Timestamp
__git_ps1_pre+='\t'
__git_ps1_pre+="\[${Color_Off}\]"

__git_ps1_pre+=' | '

__git_ps1_pre+="\[${BIBlue}\]"
# Host and OS
__git_ps1_pre+="$(.host)"
if ! [ -z ${METHOD_OS} ]; then
    __git_ps1_pre+=' (${METHOD_OS})'
else
    __git_ps1_pre+=' (${OS})'
fi
__git_ps1_pre+="\[${Color_Off}\]"

__git_ps1_pre+=' | '

__git_ps1_pre+="\[${IWhite}\]"
# User
__git_ps1_pre+='\u'
__git_ps1_pre+="\[${Color_Off}\]"

__git_ps1_pre+=' | '

__git_ps1_pre+="\[${BIYellow}\]"
# Shell Level
__git_ps1_pre+="SHLVL: ${SHLVL}$(.subshell)"
__git_ps1_pre+="\[${Color_Off}\]"

__git_ps1_pre+=' | '

__git_ps1_pre+="\[${BIPurple}\]"
# Local / Remote / Docker
__git_ps1_pre+="$(.remote)"
__git_ps1_pre+="\[${Color_Off}\]"

__git_ps1_pre+=' | '

__git_ps1_pre+="\[${ICyan}\]"
# Method Pipeline
#__git_ps1_pre+='$(.m_variables) (View: ${MPRODUCTION_VIEW})'
__git_ps1_pre+="\[${Color_Off}\]"


# =============================================================================
# __git_ps1 POST
# =============================================================================

__git_ps1_post="\[${BWhite}\]"
# Present Working Directory on newline
__git_ps1_post+='\n'
__git_ps1_post+='\w'
__git_ps1_post+="\[${Color_Off}\]"

# Put prompt on newline
__git_ps1_post+='\n> '
#__git_ps1_post+=$(.title)


# =============================================================================
# git
# =============================================================================

.git_info() {
    # Print current git branch (with text)
    git_root=$(PATH=/usr/bin git rev-parse --show-toplevel 2>/dev/null)

    # Determine if under techpub control
    if [ -f ${git_root}/.techpub.yaml ]; then
        printf " \e[7m(TECHPUB)\[${Color_Off}\]"
    fi
}


# =============================================================================
# PROMPT_COMMAND (using __git_ps1)
# =============================================================================

# __git_ps1 3 arguments: pre, post, ormat (split into 2 parts)
export PROMPT_COMMAND='PATH=/usr/bin __git_ps1 "${__git_ps1_pre}" "${__git_ps1_post}"'
export PROMPT_COMMAND+=' "\ngit Repo (branch: %s) $(.git_info)"'


# =============================================================================

# Discuss with Sam Kao how best to use this
#export MSS_PROMPT='\n\n${promptLocation} | ${promptTime} | ${promptHost} | ${promptEntity}\n${promptCwd}\n${promptSHLVL} > ';
